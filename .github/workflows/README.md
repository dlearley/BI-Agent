# GitHub Actions CI/CD Workflows

This directory contains GitHub Actions workflows for continuous integration and deployment.

## Workflows

### CI Pipeline (`ci.yml`)

The main CI pipeline runs on push to main/develop branches and on pull requests. It includes the following jobs:

#### 1. Lint
- **Purpose**: Code quality checks
- **Tools**: ESLint, TypeScript compiler
- **Steps**:
  - Install dependencies with pnpm caching
  - Run ESLint on TypeScript files
  - Run TypeScript type checking
  - Compile TypeScript to verify no compilation errors

#### 2. Test
- **Purpose**: Run unit and integration tests
- **Tools**: Jest, PostgreSQL, Redis
- **Services**: PostgreSQL 15, Redis 7
- **Steps**:
  - Install dependencies with pnpm caching
  - Run Jest tests
  - Generate coverage report
  - Upload coverage artifacts

#### 3. Build
- **Purpose**: Verify application builds successfully
- **Steps**:
  - Install dependencies with pnpm caching
  - Build TypeScript application
  - Upload build artifacts

#### 4. Security
- **Purpose**: Security vulnerability scanning
- **Tools**: npm audit
- **Steps**:
  - Run npm audit (moderate level - warnings only)
  - Run npm audit for production dependencies (high level - strict)

#### 5. Docker
- **Purpose**: Build Docker images
- **Steps**:
  - Build Docker image for analytics-service
  - Use GitHub Actions cache for Docker layers

#### 6. Docker Compose Smoke Test
- **Purpose**: End-to-end smoke test using docker-compose
- **Steps**:
  - Start all services (analytics-backend, PostgreSQL, Redis)
  - Verify service health endpoints
  - Check PostgreSQL connectivity
  - Check Redis connectivity
  - Stop and clean up services

#### 7. Typed Client Check
- **Purpose**: Verify TypeScript type definitions are generated
- **Steps**:
  - Build application
  - Verify TypeScript declaration files exist
  - Confirm type safety

#### 8. Playwright E2E Tests
- **Purpose**: Run end-to-end tests with Playwright
- **Tools**: Playwright, xvfb (headless browser)
- **Services**: PostgreSQL 15, Redis 7
- **Steps**:
  - Install dependencies with pnpm caching
  - Install Playwright browsers with dependencies
  - Build application
  - Start application server in background
  - Wait for server to be healthy
  - Run Playwright tests
  - Upload test reports and logs

#### 9. All Checks
- **Purpose**: Aggregate status of all jobs
- **Behavior**: Fails if any job fails, succeeds if all pass

### Playwright Tests (`playwright.yml`)

Dedicated workflow for Playwright E2E tests (can be run separately):

- Runs on push/PR events
- Sets up PostgreSQL and Redis services
- Installs Playwright browsers with system dependencies
- Starts the application server
- Runs E2E tests
- Uploads test reports and server logs

## Caching Strategy

### pnpm Cache
All workflows use Node.js setup with pnpm caching:
```yaml
- uses: actions/setup-node@v4
  with:
    node-version: '18'
    cache: 'pnpm'
```

### Docker Layer Cache
Docker builds use GitHub Actions cache:
```yaml
cache-from: type=gha
cache-to: type=gha,mode=max
```

## Environment Variables

### Required for All Jobs
- `NODE_VERSION`: '18'
- `PNPM_VERSION`: '8.10.0'

### Required for Tests
- `DATABASE_URL`: PostgreSQL connection string
- `REDIS_URL`: Redis connection string
- `JWT_SECRET`: JWT signing secret
- `NODE_ENV`: 'test'

### Required for Docker Compose
- All environment variables from `.env.example`

## Triggering Workflows

Workflows trigger on:
- Push to `main`, `develop`, or `ci-github-actions-workflows-*` branches
- Pull requests to `main` or `develop` branches

## Artifacts

### Coverage Report
- Generated by: Test job
- Location: `analytics-service/coverage/`
- Retention: 7 days

### Build Artifacts
- Generated by: Build job
- Location: `analytics-service/dist/`
- Retention: 7 days

### Playwright Report
- Generated by: Playwright job
- Location: `analytics-service/playwright-report/`
- Retention: 7 days

### Server Logs
- Generated by: Playwright job (on failure)
- Location: `server.log`
- Retention: 7 days

## Local Development

### Run Tests Locally

```bash
# Install dependencies
npm install

# Run linting
npm run lint

# Run unit tests
npm test

# Run tests with coverage
npm run test:coverage

# Run E2E tests (requires services)
npm run test:e2e
```

### Run Docker Compose Locally

```bash
cd analytics-service

# Start services
docker-compose up -d

# Check service health
docker-compose ps

# View logs
docker-compose logs -f

# Stop services
docker-compose down -v
```

## Troubleshooting

### Lint Failures
- Review ESLint configuration in `.eslintrc.json`
- Run `npm run lint:fix` to auto-fix issues
- Check TypeScript compilation errors

### Test Failures
- Ensure PostgreSQL and Redis services are healthy
- Check test environment variables
- Review test logs in artifacts

### Docker Build Failures
- Verify Dockerfile syntax
- Check build context and file paths
- Review Docker build logs

### Playwright Failures
- Ensure application server starts successfully
- Check health endpoint responds correctly
- Review Playwright report artifacts
- Check server logs for errors

## Security Scanning

The workflow includes security scans:
- **npm audit**: Checks for known vulnerabilities in dependencies
- **Production check**: Strict check for production dependencies only
- **Audit level**: High-severity vulnerabilities fail the build

## Best Practices

1. **Always run tests locally before pushing**
2. **Keep dependencies up to date**
3. **Review security audit warnings**
4. **Monitor workflow execution times**
5. **Clean up old artifacts regularly**
6. **Use branch protection rules requiring CI to pass**

## Future Enhancements

Potential improvements to consider:
- Add code coverage requirements
- Implement parallel test execution
- Add performance testing
- Integrate dependency scanning tools (e.g., Snyk, Dependabot)
- Add deployment workflows for staging/production
- Implement semantic versioning and releases
